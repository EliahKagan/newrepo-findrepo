#!/usr/bin/env python3

import collections
import contextlib
import glob
import math
import os
import sys

# The directory on the server where repos are kept.
REPO_DIR = '/repos'

# The typical URL for a repo, up to but not including the repo name itself.
URL_PREFIX = 'ssh://team-roach.ddns.net/repos/'

# The extension that's expected, stripped from, and restored to repo pathnames.
GIT_SUFFIX = '.git'

# This environment variable has us print all cosine similarities. (See below.)
COSINE_SIMILARITY_DEBUG_TRIGGER = 'DEBUG_COSINE_SIMILARITY'

# When no repo matches the user's pattern, even case-insensitively, we guess
# based on cosine similarity of multisets of proper substrings. We show at
# least this many guesses unless no known repos have even slightly similar
# names. And we may show more, if it would be confusing not to. (See below.)
COSINE_SIMILARITY_SUGGESTION_COUNT = 5
# TODO: Show more results if similarity is high, and fewer if it is low.

# Repos with cosine similarity less than this value to this pattern will not be
# shown, even if they are the closest matches.
COSINE_SIMILARITY_CUTOFF = 0.1

# In accordance with the principle of least astonishment, if a guessed repo is
# listed, all repos that match at least as well are listed too. It feels like
# we should also print repo names that match slightly less well, such that the
# difference in strength is almost surely irrelevant. However, it might be bad
# that we are doing this transitively. To experiment, change this constant to
# some slightly greater (or perhaps smaller, but still nonnegative) value.
# Also, you might want matches that are believed to be fairly bad, for
# debugging. For that, increase this to some still bigger positive value.
COSINE_SIMILARITY_EPSILON = 0.0001

assert COSINE_SIMILARITY_SUGGESTION_COUNT > 0
assert COSINE_SIMILARITY_CUTOFF > 0.0
assert COSINE_SIMILARITY_EPSILON >= 0.0


class LazyRowSorter:
    '''An associative table that sorts its rows when they are accessed.'''
    def __init__(self):
        '''Creates a LazyRowSorter that doesn't have any rows yet.'''
        # Not a defaultdict. Nonexistent row *retrieval* should raise KeyError.
        self._rows = {}

    def __bool__(self):
        '''Indicates if the table is nonempty (i.e., has one or more rows).'''
        return bool(self._rows)

    def __getitem__(self, key):
        '''Sorts and returns the row for key. Raises KeyError on failure.'''
        # The expected use is to retrieve a row 0, 1, or occasionally 2 times.
        # Even if it happens more, Timsort is very fast with presorted data.
        row = self._rows[key]
        assert row, "empty rows shouldn't have been made in the first place"
        row.sort()
        return row

    def put(self, key, item):
        '''Adds item to the for for key. Creates the row if there isn't one.'''
        try:
            self._rows[key].append(item)
        except KeyError:
            self._rows[key] = [item]

    def keys(self):
        '''Provides a view of the keys to each row.'''
        return self._rows.keys()


Guess = collections.namedtuple('Guess', ('key', 'similarity'))

Guess.__doc__ = '''
A case-folded repo name and its cosine similarity
to some case-folded user-provided pattern.
'''


def usage():
    '''Prints a usage message and exits.'''
    print('Usage:  %s <repo>' % sys.argv[0], file=sys.stderr)
    sys.exit(1)


def trim_suffix(path):
    '''Assumes path ends in ".git" and removes it.'''
    assert path.endswith(GIT_SUFFIX), 'the suffix to be trimmed is not present'
    return path[:-len(GIT_SUFFIX)]


def get_pattern():
    '''Interprets the command-line argument as the name of a possible repo.'''
    if len(sys.argv) != 2:
        usage()
    arg = sys.argv[1]
    if '/' in arg or not arg:  # we want a valid dir name (or its basename)
        usage()
    return trim_suffix(arg) if arg.endswith(GIT_SUFFIX) else arg


def all_repos():
    '''Gets the names of all repos.'''
    os.chdir(REPO_DIR)
    return map(trim_suffix, glob.iglob('?*' + GIT_SUFFIX))


def group_by_casefold(names):
    '''Groups names by case-folding equivalence.'''
    table = LazyRowSorter()
    for name in names:
        table.put(name.casefold(), name)
    return table


def show_url(repo):
    '''Displays the repo URL in a manner similar to the output of newrepo.'''
    print('The URL for the repository "%s" is:' % repo)
    print()
    print('\t%s%s%s' % (URL_PREFIX, repo, GIT_SUFFIX))
    print()


def show_repos(row):
    '''Prints all repo names from row.'''
    for repo in row:
        print('\t%s' % repo)


def show_repos_with_match_mark(row, pattern):
    '''Prints all repo names from row, indicating which matches the pattern.'''
    for repo in row:
        mark = '*' if repo == pattern else ''
        print('%7s %s' % (mark, repo))


def show_exact_match(pattern, row):
    '''Assumes an exact match, shows it, and warns about any case clashes.'''
    show_url(pattern)

    if len(row) != 1:
        # Warn the user that there are multiple case-insensitive matches.
        situation = 'named like this by capitalized differently'
        if len(row) == 2:
            print('BEWARE! Another repo is %s.' % situation)
        else:
            print('BEWARE! %d other repos are %s.' % (len(row) - 1, situation))
        print()
        show_repos_with_match_mark(row, pattern)
        print()


def show_unique_casefold(pattern, row):
    '''Assumes an inexact unique case-insensitive match. Shows it and warns.'''
    print('I have no "%s" repo. Perhaps you mean "%s"?' % (pattern, row[0]))
    print()
    show_url(row[0])
    print("BEWARE! The filesystem on this server is case-sensitive.")


def show_multiple_casefolds(pattern, row):
    '''Assumes no exact match and two or more casefolds. Shows them all.'''
    print('I have no "%s" repo. Maybe you want one of these...' % pattern)
    print()
    show_repos(row)
    print()
    print('Those repos are like what you requested,'
          ' but with different capitalization.')
    print('If any of those look EXACTLY the same,'
          ' they may have weird Unicode characters.')


def substring_frequency_vector(key):
    '''Computes (substring -> frequency) mappings, represented as a Counter.'''
    return collections.Counter(key[start:stop]
                               for stop in range(len(key) + 1)
                               for start in range(stop))


def _inner_product(u, v):
    '''Does the actual work of computing the (substr -> freq) dot product.'''
    return sum(freq * v[substr] for substr, freq in u.items())


def inner_product(u, v):
    '''Computes the dot product of two (substr -> freq) mappings.'''
    # Iterate through the vector with smaller support, to save time.
    return _inner_product(v, u) if len(v) < len(u) else _inner_product(u, v)


def square(u):
    '''Computes the dot product of a (substr -> freq) mapping with itself.'''
    return sum(freq * freq for freq in u.values())


def debug_guesses(guesses):
    '''Prints all cosine similarities if the trigger to do so is defined.'''
    if COSINE_SIMILARITY_DEBUG_TRIGGER in os.environ:
        print('The environment variable %s is defined. The following'
              % COSINE_SIMILARITY_DEBUG_TRIGGER, file=sys.stderr)
        print('is a table of cosine similarities between the pattern key'
              ' and EACH repo key:', file=sys.stderr)
        for key, similarity in guesses:
            print('\t%.6f\t%s' % (similarity, key), file=sys.stderr)
        print(file=sys.stderr)


def keys_with_substring_cosine_similarity(keys, pattern_key):
    '''
    Gets all keys, in descending order of similarity to pattern_key. In cases
    of equal similarity, the tie is broken lexicographically by key text.
    '''
    # This implementation precomputes squares, not norms, for better precision.
    vectors = {key: substring_frequency_vector(key) for key in keys}
    squares = {key: square(v) for key, v in vectors.items()}
    pattern_vector = substring_frequency_vector(pattern_key)
    pattern_square = square(pattern_vector)

    def pattern_similarity(key):
        return (inner_product(vectors[key], pattern_vector)
                / math.sqrt(squares[key] * pattern_square))

    guesses = [Guess(key, pattern_similarity(key)) for key in keys]
    guesses.sort(key=lambda guess: (-guess.similarity, guess.key))
    debug_guesses(guesses)
    return guesses


def plausible_guesses(keys, pattern_key):
    '''Gets all guesses that seem good enough to possibly show the user.'''
    # Computing substring cosine similarities is the asymptotically slowest
    # step and COSINE_SIMILARITY_CUTOFF is small. If we pruned guesses before
    # sorting when we didn't have COSINE_SIMILARITY_DEBUG_TRIGGER but after
    # sorting when we did, the program would be more complicated and bug-prone,
    # with only a small improvement in peformance. For the same reason, I
    # haven't written a binary search, nor made Guess a fully-fledged class
    # with __lt__ to use the bisect module (note also that such a class would
    # likely need __slots__ for the effect on performance to remain positive).
    guesses = keys_with_substring_cosine_similarity(keys, pattern_key)

    # Usually we keep most guesses, so check them from right to left.
    with contextlib.suppress(IndexError):
        while guesses[-1].similarity < COSINE_SIMILARITY_CUTOFF:
            del guesses[-1]

    return guesses

def announce_guesses(guesses, table, pattern):
    '''Prints a heading explaining if guesses are about to be suggested.'''
    situation = 'I have no "%s" repo' % pattern
    if not guesses:
        print('%s, nor any named even vaguely like it.' % situation)
    elif len(guesses) == 1 and len(table[guesses[0].key]) == 1:
        print('%s. This repo has a vaguely similar name...' % situation)
    else:
        print('%s. These repos have vaguely similar names...' % situation)

def suggest_guesses(guesses, table):
    '''Suggests guesses to the user.'''
    prev_similarity = float('inf')  # Becuase Python 3.4 doesn't have math.inf.
    remaining = COSINE_SIMILARITY_SUGGESTION_COUNT

    for key, similarity in guesses:
        delta = prev_similarity - similarity
        assert delta >= 0.0, 'guesses must be sorted from more to less similar'
        if remaining <= 0 and delta > COSINE_SIMILARITY_EPSILON:
            break

        prev_similarity = similarity
        row = table[key]
        remaining -= len(row)
        show_repos(row)


# Get the pattern now so we fail fast on syntax errors.
pattern = get_pattern()

# Retrieve the repos. Stop if there weren't any, which we consider an error.
repos = all_repos()
if not repos:
    print('I have no "%s" repo. In fact, I have no repos at all!' % pattern)
    exit(1)

# We need this even if pattern is an exact match, to warn about other variants.
table = group_by_casefold(repos)
pattern_key = pattern.casefold()
assert pattern_key, "case folding shouldn't make a non-empty string empty"

try:
    row = table[pattern_key]

    # We at least have a case-insensitive match.
    if pattern in row:
        show_exact_match(pattern, row)
    elif len(row) == 1:
        show_unique_casefold(pattern, row)
    else:
        show_multiple_casefolds(pattern, row)
except KeyError:
    # We don't even have a case-insensitive match.
    guesses = plausible_guesses(table.keys(), pattern_key)

    announce_guesses(guesses, table, pattern)

    if guesses:
        print()
        suggest_guesses(guesses, table)
        print()
