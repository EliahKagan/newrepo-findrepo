#!/usr/bin/env python3

import collections
import contextlib
import glob
import math
import os
import sys

# The extension that is expected, stripped from, and restored to repo pathnames.
GIT_SUFFIX = '.git'

# This environment variable makes us print all cosine similarities. (See below.)
COSINE_SIMILARITY_DEBUG_TRIGGER = 'DEBUG_COSINE_SIMILARITY'

# When no repo matches the user's pattern, even case-insensitively, we guess
# based on cosine similarity of multisets of proper substrings. We show at least
# this many guesses unless no known repos have even slightly similar names. Note
# that we may show more, if it would be confusing not to. (See below.)
COSINE_SIMILARITY_SUGGESTION_COUNT = 5
# TODO: Show more results if similarity is high, and fewer if it is low.

# Repos with cosine similarity less than this value to this pattern will not be
# shown, even if they are the closest matches.
COSINE_SIMILARITY_CUTOFF = 0.1

# In accordance with the principle of least astonishment, if a guessed repo is
# listed, all repos that match at least as well are listed too. It feels like
# we should also print repo names that match slightly less well, such that the
# difference in strength is almost surely irrelevant. However, since this
# very likely should not be done transitively, it might be worse. To experiment,
# increase this constant to some strictly positive, but still small, value.
# Also, you might want matches that are believed to be fairly bad, for debugging
# purposes. For that, increase this to some even bigger positive value.
COSINE_SIMILARITY_EPSILON = 0.0

assert COSINE_SIMILARITY_SUGGESTION_COUNT > 0
assert COSINE_SIMILARITY_CUTOFF > 0.0
assert COSINE_SIMILARITY_EPSILON >= 0.0

class LazyRowSorter:
    '''An associative table that sorts its rows when they are accessed.'''
    def __init__(self):
        '''Creates a LazyRowSorter that doesn't have any rows yet.'''
        # Not a defaultdict. Nonexistent row *retrieval* should raise KeyError.
        self._rows = {}
    
    def __getitem__(self, key):
        '''Sorts and returns the row for key. Raises KeyError on failure.'''
        # The expected use case is to retrieve each rows just once. Even if rows
        # are retrieved repeatedly, Timsort is very fast with presorted data.
        row = self._rows[key]
        assert row, "empty rows shouldn't have been made in the first place"
        row.sort()
        return row
    
    def put(self, key, item):
        '''Adds item to the for for key. Creates the row if there isn't one.'''
        try:
            self._rows[key].append(item)
        except KeyError:
            self._rows[key] = [item]
    
    def keys(self):
        '''Provides a view of the keys to each row.'''
        return self._rows.keys()

Guess = collections.namedtuple('Guess', ('key', 'similarity'))

def usage():
    '''Prints a usage message and exits.'''
    print('Usage:  %s <repo>' % sys.argv[0], file=sys.stderr)
    sys.exit(1)

def trim_suffix(path):
    '''Assumes path ends in ".git" and removes it.'''
    assert path.endswith(GIT_SUFFIX)
    return path[:-4]

def get_pattern():
    '''Interprets the command-line argument as the name of a possible repo.'''
    if len(sys.argv) != 2:
        usage()
    arg = sys.argv[1]
    if '/' in arg or not arg: # we want a valid directory name (or its basename)
        usage()
    return trim_suffix(arg) if arg.endswith(GIT_SUFFIX) else arg

def all_repos():
    '''Gets the names of all repos.'''
    os.chdir('/repos')
    return map(trim_suffix, glob.iglob('?*' + GIT_SUFFIX))

def all_repos_case_variants():
    '''Gets the names of all repos and groups them by case-equivalence.'''
    table = LazyRowSorter()
    for repo in all_repos():
        table.put(repo.casefold(), repo)
    return table

def show_url(repo):
    '''Displays the repo URL in a manner similar to the output of newrepo.'''
    print('The URL for the repository "%s" is:' % repo)
    print()
    print('\tssh://team-roach.ddns.net/repos/%s%s' % (repo, GIT_SUFFIX))
    print()

def show_repos(row):
    '''Prints all repo names from row.'''
    for repo in row:
        print('\t%s' % repo)

def substring_frequency_vector(key):
    '''Computes (substring -> frequency) mappings. Returns them as a Counter.'''
    return collections.Counter(key[start:stop] for stop in range(len(key) + 1)
                                               for start in range(stop))

def _inner_product(u, v):
    '''Does the actual work of computing the (substr -> freq) dot product.'''
    return sum(freq * v[substr] for substr, freq in u.items())

def inner_product(u, v):
    '''Computes the dot product of two (substr -> freq) mappings.'''
    # Iterate through the vector with smaller support, to save time.
    return _inner_product(v, u) if len(v) < len(u) else _inner_product(u, v)

def square(u):
    '''Computes the dot product of a (substr -> freq) mapping with itself.'''
    return sum(freq * freq for freq in u.values())

def debug_guesses(guesses):
    '''Prints all cosine similarities if the trigger to do so is defined.'''
    if COSINE_SIMILARITY_DEBUG_TRIGGER in os.environ:
        print('The environment variable %s is defined. The following'
                % COSINE_SIMILARITY_DEBUG_TRIGGER, file=sys.stderr)
        print('is a table of cosine similarities between the pattern key'
              ' and EACH repo key:', file=sys.stderr)
        for key, similarity in guesses:
            print('\t%.6f\t%s' % (similarity, key), file=sys.stderr)
        print(file=sys.stderr)

def keys_with_substring_cosine_similarity(keys, pattern_key):
    '''
    Gets all keys, in descending order of similarity to pattern_key. In cases of
    equal similarity, the tie is broken lexicographically by key text.
    '''
    # This implementation precomputes squares, not norms, for better precision.
    vectors = {key: substring_frequency_vector(key) for key in keys}
    squares = {key: square(v) for key, v in vectors.items()}
    pattern_vector = substring_frequency_vector(pattern_key)
    pattern_square = square(pattern_vector)

    def pattern_similarity(key):
        return (inner_product(vectors[key], pattern_vector)
                    / math.sqrt(squares[key] * pattern_square))
    
    guesses = [Guess(key, pattern_similarity(key)) for key in keys]
    guesses.sort(key=lambda guess: (-guess.similarity, guess.key))
    debug_guesses(guesses)
    return guesses

# Get the pattern now so we fail fast on syntax errors.
pattern = get_pattern()

# We need this even if pattern is an exact match, to warn about other variants.
table = all_repos_case_variants()
pattern_key = pattern.casefold()
assert pattern_key, "case folding shouldn't make a non-empty string empty"

try:
    row = table[pattern_key]
    if pattern in row:
        # We have an exact match.
        show_url(pattern)

        if len(row) != 1:
            # Warn the user that there are multiple case-insensitive matches.
            if len(row) == 2:
                print('BEWARE! Another repo is named like this'
                      ' but capitalized differently.')
            else:
                print('BEWARE! %d other repos are named like this'
                      ' but capitalized differently.' % (len(row) - 1))
            print()

            for repo in row:
                mark = '*' if repo == pattern else ''
                print('%7s %s' % (mark, repo))
            print()
    elif len(row) == 1:
        # We have no exact match, but there is a unique case-insensitive match.
        print('I have no "%s" repo. Perhaps you mean "%s"?' % (pattern, row[0]))
        print()
        show_url(row[0])
        print("BEWARE! The filesystem on this server is case-sensitive.")
    else:
        # We have no exact match. There are multiple case-insensitive matches.
        print('I have no "%s" repo. Maybe you want one of these...' % pattern)
        print()
        show_repos(row)
        print()
        print('Those repos are like what you requested,'
              ' but with different capitalization.')
        print('If any of those look EXACTLY the same,'
              ' they may have weird Unicode characters.')
except KeyError:
    # We don't even have a case-insensitive match. Suggest guesses to the user.
    guesses = keys_with_substring_cosine_similarity(table.keys(), pattern_key)
    if not guesses:
        print('I have no "%s" repo. In fact, I have no repos at all!' % pattern)
        exit(0)
    
    prev_similarity = guesses[0].similarity
    if prev_similarity < COSINE_SIMILARITY_CUTOFF:
        print('I have no "%s" repo, nor any named even vaguely like it.'
                % pattern)
        exit(0)
    
    print('I have no "%s" repo. These repos have vaguely similar names...'
            % pattern)
    print()

    remaining = COSINE_SIMILARITY_SUGGESTION_COUNT
    for key, similarity in guesses:
        delta = prev_similarity - similarity
        assert delta >= 0.0, 'guesses must be sorted from more to less similar'
        if ((remaining <= 0 and delta > COSINE_SIMILARITY_EPSILON)
                or similarity < COSINE_SIMILARITY_CUTOFF):
            break
        
        prev_similarity = similarity
        row = table[key]
        remaining -= len(row)
        show_repos(row)
    
    print()
