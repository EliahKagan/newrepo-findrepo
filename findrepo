#!/usr/bin/env python3

import collections
import contextlib
import glob
import math
import os
import sys

# The extension that is expected, stripped from, and restored to repo pathnames.
GIT_SUFFIX = '.git'

# This environment variable makes us print all cosine similarities. (See below.)
COSINE_SIMILARITY_DEBUG_TRIGGER = 'DEBUG_COSINE_SIMILARITY'

# When no repo matches the user's pattern, even case-insensitively, we guess
# based on cosine similarity of multisets of proper substrings. We will show
# at least this many guesses unless it is more than the number of known repos.
# However, we may show more, if it would be confusing not to (see below).
COSINE_SIMILARITY_SUGGESTION_COUNT = 5

# In accordance with the principle of least astonishment, if a guessed repo is
# listed, all repos that match at least as well are listed too. It feels like
# we should also print repo names that match slightly less well, such that the
# difference in strength is almost surely irrelevant. However, since this
# probably should not be done transitively, it might be worse. To experiment,
# increase this constant to some strictly positive, but still small, value.
# Also, you might want matches that are believed to be fairly bad, for debugging
# purposes. For that, increase this to some even bigger positive value.
COSINE_SIMILARITY_EPSILON = 0.0

assert(COSINE_SIMILARITY_SUGGESTION_COUNT > 0)
assert(COSINE_SIMILARITY_EPSILON >= 0.0)

Guess = collections.namedtuple('Guess', ('key', 'similarity'))

def usage():
    '''Prints a usage message and exits.'''
    print('Usage:  %s <repo>' % sys.argv[0])
    sys.exit(1)

def trim_suffix(path):
    '''Assumes path ends in ".git" and removes it.'''
    assert path.endswith(GIT_SUFFIX)
    return path[:-4]

def get_pattern():
    '''Interprets the command-line argument as the name of a possible repo.'''
    if len(sys.argv) != 2:
        usage()
    arg = sys.argv[1]
    if '/' in arg or not arg: # we want a valid directory name (or its basename)
        usage()
    return trim_suffix(arg) if arg.endswith(GIT_SUFFIX) else arg

def all_repos():
    '''Gets the names of all repos.'''
    os.chdir('/repos')
    return map(trim_suffix, glob.iglob('?*' + GIT_SUFFIX))

def all_repos_case_variants():
    '''Gets the names of all repos and groups them by case-equivalence.'''
    case_variants = {} # not using defaultdict because we want exceptions later
    for repo in all_repos():
        key = repo.casefold()
        try:
            case_variants[key].append(repo)
        except KeyError:
            case_variants[key] = [repo]
    return case_variants

def show_url(repo):
    '''Displays the repo URL in a manner similar to the output of newrepo.'''
    print('The URL for the repository "%s" is:' % repo)
    print()
    print('\tssh://team-roach.ddns.net/repos/%s%s' % (repo, GIT_SUFFIX))
    print()

def show_repos(row):
    '''Prints all repo names from row.'''
    for repo in row:
        print('\t%s' % repo)

def substring_frequency_vector(key):
    '''Computes (substring -> frequency) mappings. Returns them as a Counter.'''
    return collections.Counter(key[start:stop] for stop in range(len(key) + 1)
                                               for start in range(j))

def inner_product(u, v):
    '''Computes the dot product of two (substr -> freq) mappings.'''
    return sum(freq * v[substr] for substr, freq in u.items())

def square(u):
    '''Computes the inner product of a (substr -> freq) mapping with itself.'''
    return sum(freq * freq for freq in u.values())

def keys_with_substring_cosine_similarity(keys, pattern_key):
    '''Get all keys, sorted so keys more similar to pattern_key appear first.'''
    # This implementation precomputes squares, not norms, for better precision.
    vectors = {key: substring_frequency_vector(key) for key in keys}
    squares = {key: square(v) for key, v in vectors.items()}
    pattern_vector = substring_frequency_vector(pattern_key)
    pattern_square = square(pattern_vector)

    def pattern_similarity(key):
        print('DEBUG: {}, {}'.format(squares[key], pattern_square),
              file=sys.stderr) # FIXME: remove this statement after debugging!
        return (inner_product(vectors[key], pattern_vector)
                    / math.sqrt(squares[key] * pattern_square))
    
    guesses = [Guess(key, pattern_similarity(key)) for key in keys]
    guesses.sort(key=lambda guess: (-guess.similarity, guess.key))

    if COSINE_SIMILARITY_DEBUG_TRIGGER in os.environ:
        print('The environment variable %s is defined. The following'
                % COSINE_SIMILARITY_DEBUG_TRIGGER, file=sys.stderr)
        print('is a table of cosine similarities between the pattern key'
              ' and EACH repo key:', file=sys.stderr)
        for key, similarity in guesses:
            print('\t%.6f\t%s' % (similarity, key), file=sys.stderr)
        print(file=sys.stderr)
    
    return guesses

# Get the pattern now so we fail fast on syntax errors.
pattern = get_pattern()

# We need this even if pattern is an exact match, to warn about other variants.
table = all_repos_case_variants()
def table_row(key):
    '''Retrieve, sort, and return a row in the table.'''
    row = table[key]
    assert row, "empty rows shouldn't have been made in the first place"
    row.sort()
    return row

pattern_key = pattern.casefold()
assert pattern_key, 'case-folding a non-empty string should be non-empty'

try:
    row = table_row(pattern_key)
    if pattern in row:
        # We have an exact match.
        show_url(pattern)

        if len(row) != 1:
            # Warn the user that there are multiple case-insensitive matches.
            if len(row) == 2:
                print('BEWARE! Another repo is named like this'
                      ' but capitalized differently.')
            else:
                print('BEWARE! %d other repos are named like this'
                      ' but capitalized differently.' % (len(row) - 1))
            print()

            for repo in row:
                mark = '*' if repo == pattern else ''
                print('%7s %s' % (mark, repo))
            print()
    elif len(row) == 1:
        # We have no exact match, but there is a unique case-insensitive match.
        print('I have no "%s" repo. Perhaps you mean "%s"?' % (pattern, row[0]))
        print()
        show_url(row[0])
        print("BEWARE! The filesystem on this server is case-sensitive.")
    else:
        # We have no exact match. There are multiple case-insensitive matches.
        print('I have no "%s" repo. Maybe you want one of these...' % pattern)
        print()
        show_repos(row)
        print()
        print('Those repos are like what you requested,'
              ' but with different capitalization.')
        print('If any of those look EXACTLY the same,'
              ' they may have weird Unicode characters.')
except KeyError:
    # We don't even have a case-insensitive match. Suggest guesses to the user.
    guesses = keys_with_substring_cosine_similarity(table.keys(), pattern_key)
    if not guesses:
        print('I have no "%s" repo. In fact, I have no repos at all!' % pattern)
        exit(0)
    
    print('I have no "%s" repo. These repos have vaguely similar names...'
            % pattern)
    print()

    remaining = COSINE_SIMILARITY_SUGGESTION_COUNT
    prev_similarity = float('inf')

    for key, similarity in guesses:
        assert similarity <= prev_similarity, \
               'more similar guesses should appear before less similar guesses'
        
        if remaining <= 0:
            if similarity + COSINE_SIMILARITY_EPSILON < prev_similarity:
                break
        
        prev_similarity = similarity
        row = table_row(key)
        remaining -= len(row)
        show_repos(row)
    
    print()
